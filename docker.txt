sudo yum remove docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-engine
sudo yum install -y yum-utils
sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
yum list docker-ce --showduplicates | sort -r
sudo yum install docker-ce-<VERSION_STRING> docker-ce-cli-<VERSION_STRING> containerd.io
sudo yum install docker-ce docker-ce-cli containerd.io
curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io  #镜像加速
sudo systemctl start docker
sudo docker run hello-world


*Docker:image container respository
*image:read-only template
*container:instance created from image.容器启动时创建一层可写层作为最上层
*Regisrty存放多个respository,每个respository包含多个image.respository include privite and public.
*service dockrt start
*获取镜像：sudo docker pull ubuntu:12.04  指定仓库：sudo docker pull dl.dockerpool.com:5000/ubuntu:12.04
*创建容器运行bash:sudo docker run -t -i ubuntu:12.04 /bin/bash
*本地镜像：docker images
*提交副本：docker commit [-ma]
*mkdir sinatra > cd sinatra > touch Dockerfile > 在dockerfile中写入下面信息 > sudo	docker	build	-t="ouruser/sinatra:v2" .  
#	This	is	a	comment
FROM	ubuntu:14.04
MAINTAINER	Docker	Newbee	<newbee@docker.com> # 维护者信息
RUN	apt-get	-qq	update
RUN	apt-get	-qqy	install	ruby	ruby-dev
RUN	gem	install	sinatra
*修改镜像标签：	sudo docker	tag	5db5f8471261 ouruser/sinatra:devel
*本地文件系统导入镜像：sudo	cat	ubuntu-14.04-x86_64-minimal.tar.gz |docker import - ubuntu:14.04
*docker hub注册后推送镜像：sudo docker push ouruser/sinatra
*存出镜像：sudo	docker save -o ubuntu_14.04.tar	ubuntu:14.04
*载入镜像：sudo docker load --input                              ubuntu_14.04.tar
*移除本地镜像：docker rmi training/sinatra 删除前用docker rm 删除依赖于此镜像的所有容器
*新建启动：	sudo docker run -t -i ubuntu:12.04 /bin/bash
*启动已终止容器:docker start
*终止容器：docker stop
*进入容器：docker attach ID 也可使用nsenter或下载.bashrc_docker
------------------------------------------------------------------------------------操作--------------------------------------------------------
*底层技术支持：Namespaces（做隔离）、CGroups（做资源限制）、UnionFS（镜像和容器的分层） the-underlying-technology Docker 底层架构分析
*docker engine包括：CLI->REST API->dockerd
*Docker Damon：dockerd，用来监听 Docker API 的请求和管理 Docker 对象，比如镜像、容器、网络和 Volume。
*docker pull [选项] [Docker Registry 地址[:端口]/]仓库名[:标签]
*docker run -it --rm ubuntu:16.04 /bin/bash    #容器exit退出后删除
*docker image ls
*docker system df
*docker run来创建容器时,检查本地是否存在指定的镜像，不存在就从公有仓库下载。利用镜像创建并启动一个容器。分配一个文件系统，并在只读的镜像层外面挂载一层可读写层。从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去。从地址池配置一个 ip 地址给容器。执行用户指定的应用程序，执行完毕后容器被终止。
*docker container ls -a   
*docker container start ID 
*docker run -d ubuntu:16.04 /bin/sh -c "while true; do echo hello world; sleep 1; done"   # -d后台运行
*docker container logs ID
*docker container stop ID
*docker exec -it ID bash  #进入容器，退出后不会终止
*docker container rm ID
*docker container prune  或 docker ps -aq  #删除所有终止的容器
*docker rmi 镜像名
*docker run --name webserver -d -p 80:80 nginx
*docker diff webserver  
*docker commit --author "lz" --message "修改了默认首页" webserver nginx:v2   #保存为镜像
*docker history nginx:v2
*docker run --name webserv2 -d -p 81:80 nginx:v2   # http://localhost:81
---------------------------------------------------------------------dockerfile-------------------------------------------------------
*vi Dcokerfile:
FROM nginx   #空白镜像可使用scratch
RUN echo '<h1>Hello, Docker!</h1>' > /usr/share/nginx/html/index.html
*多层写法：
FROM debian:jessie
RUN buildDeps='gcc libc6-dev make' \
    && apt-get update \
    && apt-get install -y $buildDeps \
    && wget -O redis.tar.gz "http://download.redis.io/releases/redis-3.2.5.tar.gz" \
    && mkdir -p /usr/src/redis \
    && tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \
    && make -C /usr/src/redis \
    && make -C /usr/src/redis install \
    && rm -rf /var/lib/apt/lists/* \
    && rm redis.tar.gz \
    && rm -r /usr/src/redis \
    && apt-get purge -y --auto-remove $buildDeps
*docker build -t nginx:v3 .      #构建镜像，Dockerfile 文件所在目录执行，.为上下文目录
*.dockerignore，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的
*docker save alpine | gzip > alpine-latest.tar.gz   
*docker load -i alpine-latest.tar.gz   #结合上条命令迁移镜像
*docker save <镜像名> | bzip2 | pv | ssh <用户名>@<主机名> 'cat | docker load'
--------------------------------------------------------私有仓库-------------------------------------------------
*docker login 
*docker logout
*docker search centos
*docker pull centos
*docker tag ubuntu:17.10 username/ubuntu:17.10
*docker run -d -p 5000:5000 --restart=always --name registry registry   #使用官方的registry镜像来启动私有仓库,仓库会被创建在容器的/var/lib/registry目录下, -v 参数来将镜像文件存放在本地的指定路径。例如下面的例子将上传的镜像放到本地的 /opt/data/registry 目录。
docker run -d -p 5000:5000 -v /opt/data/registry:/var/lib/registry registry
*docker tag ubuntu:latest 127.0.0.1:5000/ubuntu:latest
*docker push 127.0.0.1:5000/ubuntu:latest
*私有仓库设置，/etc/docker/daemon.json中写入:
{
  "registry-mirror": [
    "https://registry.docker-cn.com"
  ],
  "insecure-registries": [
    "192.168.199.100:5000"
  ]
}
----------------------------------------------------数据共享---------------------------
*数据卷、挂载主机目录
*数据卷是一个可供一个或多个容器使用的特殊目录，它绕过UFS,可以在容器之间共享和重用,对数据卷的修改会立马生效,对数据卷的更新，不会影响镜像，数据卷默认会一直存在，即使容器被删除
*docker volume create my-vol
*docker volume ls
*docker volume inspect my-vol  
*docker run -d -P --name web --mount source=my-vol,target=/webapp training/webapp python app.py
*docker volume rm my-vol 
*docker volume prune
*docker run -d -P --name web  -v /src/webapp:/opt/webapp:ro  training/webapp python app.py   #挂载主机目录,只读
*docker run --rm -it --mount type=bind,source=$HOME/.bash_history,target=/root/.bash_history ubuntu:17.10 bash  #挂载单个文件
-----------------------------------------------网络模式---------------------------------------
*Docker进程启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器会连接到这个虚拟网桥上。从docker0子网中分配一个 IP 给容器使用，并设置 docker0 的 IP 地址为容器的默认网关。bridge模式是 docker 的默认网络模式。
*docker run -tid --net=bridge --name docker_bri1 ubuntu-base:v3 docker run -tid --net=bridge --name docker_bri2 ubuntu-base:v3 
*docker network create -d bridge my-net
*docker run -it --rm --name busybox1 --network my-net busybox sh
*docker run -it --rm --name busybox2 --network my-net busybox sh
*ping busybox1
*如果启动容器的时候使用host模式,容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口
*docker run -tid --net=host --name docker_host1 ubuntu-base:v3
*docker exec -ti docker_host1 /bin/bash
*container模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，两个容器的进程可以通过 lo 网卡设备通信
*docker run -tid --net=container:docker_bri1 --name docker_con1 ubuntu-base:v3
*none模式，Docker 容器拥有自己的 Network Namespace，但是，并不为Docker 容器进行任何网络配置
------------------------------------------------docker compose------------------------------------------
*服务 (service)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。
*项目 (project)：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。
*二进制安装：
sudo curl -L https://github.com/docker/compose/releases/download/1.17.1/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose
sudo rm /usr/local/bin/docker-compose  #删除 
*pip安装，arm架构：
sudo pip install -U docker-compose
curl -L https://raw.githubusercontent.com/docker/compose/1.8.0/contrib/completion/bash/docker-compose > /etc/bash_completion.d/docker-compose
sudo pip uninstall docker-compose
*容器安装
curl -L https://github.com/docker/compose/releases/download/1.8.0/run.sh > /usr/local/bin/docker-compose
chmod +x /usr/local/bin/docker-compose
*docker-compose [-f=<arg>...] [options] [COMMAND] [ARGS...]
-f, --file FILE 指定使用的 Compose 模板文件，默认为 docker-compose.yml，可以多次指定。
-p, --project-name NAME 指定项目名称，默认将使用所在目录名称作为项目名。
--x-networking 使用 Docker 的可拔插网络后端特性
--x-network-driver DRIVER 指定网络后端的驱动，默认为 bridge
--verbose 输出更多调试信息。
-v, --version 打印版本并退出。
*docker-compose kill -s SIGINT
*docker-compose run ubuntu ping docker.com
*docker-compose run --no-deps web python manage.py shell  #不启动关联容器
*docker-compose scale web=3 db=2
------------------------------------------------------docker machine--------------------------------------
*Docker Machine是 Docker 官方提供的一个工具，它可以帮助我们在远程的机器上安装 Docker，或者在虚拟机 host 上直接安装虚拟机并在虚拟机中安装 Docker。我们还可以通过 docker-machine命令来管理这些虚拟机和 Docker。
*sudo curl -L https://github.com/docker/machine/releases/download/v0.13.0/docker-machine-`uname -s`-`uname -m` > /usr/local/bin/docker-machine
sudo chmod +x /usr/local/bin/docker-machine
*docker-machine create -d virtualbox test
*docker-machine create -d generic \
    --generic-ip-address=123.59.188.19 \
    --generic-ssh-user=root \
    --generic-ssh-key ~/.ssh/id_rsa \
    dev
*docker-machine ls
*docker-machine env test  #后续操作对象都是test主机
*docker-machine ssh test
*docker-machine COMMAND --help
---------------------------------------------------------docker swarm-------------------------------------------
*Swarm是使用SwarmKit构建的 Docker 引擎内置（原生）的集群管理和编排工具.用户可以将多个 Docker 主机封装为单个大型的虚拟 Docker 主机，快速打造一套容器云平台。
*运行 Docker 的主机可以主动初始化一个 Swarm 集群或者加入一个已存在的 Swarm 集群，这样这个运行 Docker 的主机就成为一个 Swarm 集群的节点 (node) 。节点分为管理 (manager) 节点和工作 (worker) 节点。
*任务（Task）是 Swarm 中的最小的调度单位，目前来说就是一个单一的容器；服务（Services）是指一组任务的集合，服务定义了任务的属性，服务有两种模式：
replicated services按照一定规则在各个工作节点上运行指定个数的任务。
global services每个工作节点上运行一个任务
*docker-machine create -d virtualbox manager
*docker swarm init   #管理节点初始化
*docker-machine create -d virtualbox worker1
*docker-machine ssh worker1
*docker node ls
*docker service ls
*docker service create --replicas 3 -p 80:80 --name nginx nginx:1.13.7-alpine
*docker service ps nginx
*docker service rm nginx
*docker stack deploy -c docker-compose.yml wordpress
*docker stack ls
*docker stack down
--------------------------------------------------多阶段构建----------------------------------
*使用多阶段构建，你可以在一个 Dockerfile 中使用多个 FROM 语句。每个 FROM 指令都可以使用不同的基础镜像，并表示开始一个新的构建阶段。你可以很方便的将一个阶段的文件复制到另外一个阶段，在最终的镜像中保留下你需要的内容即可
*FROM golang AS build-env
ADD . /go/src/app
WORKDIR /go/src/app
RUN go get -u -v github.com/kardianos/govendor
RUN govendor sync
RUN GOOS=linux GOARCH=386 go build -v -o /go/src/app/app-server

FROM alpine
RUN apk add -U tzdata
RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai  /etc/localtime
COPY --from=build-env /go/src/app/app-server /usr/local/bin/app-server
EXPOSE 8080
CMD [ "app-server" ]
*docker build -t cnych/docker-multi-stage-demo:latest .
*docker run --rm -p 8080:8080 cnych/docker-multi-stage-demo:latest


























